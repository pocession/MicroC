#' annotateDIR
#'
#' @description
#' This function reads differentially-interacted regions (DIRs) and annotate with hg38 information
#' 
#' @author Tsunghan Hsieh
#'
#' @param input a character string specifying the name and path of the input file (.csv)
#' This file should be generated by getDIRWithNoReplicate()
#' @param output A character string specifying the name and path of output file
#' the default path is as same as the treatment file
#' the default output file name is the treatment file name prefixed with "annotated_"
#' @return a dataframe of the output data
#'
#' @export
#'
#' @importFrom here here
#' @importFrom edger
#' @importFrom assertthat assert_that
#' @importFrom tidyr separate
#' @importFrom TxDb.Hsapiens.UCSC.hg38.knownGene
#' @importFrom org.Hs.eg.db
#' @importFrom GenomicRanges
#' @importFrom AnnotationDbi select
#'
#' @examples
#' \dontrun{
#' df <- annotateDIR(
#' input = here::here("./Results/DIR/DIR_44112_A_bg_43615_mc6contact_map_extracted.csv"),
#' output = NULL
#' )
#' }
#' 
## TODO
## Run getDIRWithNoReplicate() to generate DIR files

annotateDIR <- function(input, output) {
  # check input ----------------------------------------------------------------
  
  assertthat::assert_that(is.character(input), 
                          msg = "The given argument is not a string.\n")
  
  assertthat::assert_that(grepl("\\.csv$", input), 
                          msg = "The given file to the input file is not a .csv file.\n")
  
  assertthat::assert_that(file.exists(here::here(input)), 
                          msg = "The given file path to the input file does not exist.\n")
  
  # check output ---------------------------------------------------------------
  
  if (is.null(output)) {
    # Use sub() to extract the desired part
    outputfname <- sub(".*/([^.]+)\\.csv", "\\1", input)
    outputfname <- paste0("annotated_", outputfname, ".csv")
    outputdir <- dirname(input)
    output <- here::here(outputdir, outputfname)
    remove(outputfname, outputdir)
  } else {
    assertthat::assert_that(is.character(output), 
                            msg = "The given argument is not a string.\n")
    
    assertthat::assert_that(grepl("\\.csv$", output), 
                            msg = "The given file to the output file is not a .csv file.\n")
    
    assertthat::assert_that(file.exists(here::here(dirname(output))), 
                            msg = "The given file path to the expertiment file does not exist.\n")
  }
  
  
  # Assign the hg38 objects ----------------------------------------------------
  txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
  hgdb <- org.Hs.eg.db
  
  # Extract TSS positions ------------------------------------------------------
  tss <- transcripts(txdb, columns=c("tx_id", "gene_id"), use.names=TRUE)
  tss <- resize(tss, width=1, fix='start')
  tss_df <- as.data.frame(tss, row.names = NULL)
  tss_df$transcript <- row.names(tss_df)
  colnames(tss_df) <- c("tx_chr","tx_start","tx_end","tx_width","tx_strand","tx_id","gene_id","transcript")
  
  # Read DIRs ------------------------------------------------------------------
  input_df <- read.csv(input)
  input_df <- input_df[,2:ncol(input_df)]
  
  annotated_df <- .get_annotated_gr(input_df)
  write.csv(annotated_df, output)
  message("Done! The output is written in: ", output)
}


#' .get_annotated_gr
#'
#' @description
#' This function annotate differentially-interacted regions (DIRs) with given genome information
#' 
#' @author Tsunghan Hsieh
#'
#' @param input a character string specifying the input dataframe
#' @return a dataframe of annotated file
#' @examples
#' \dontrun{
#' df <- .get_annotated_gr(
#' df = input_df
#' )
#' }
.get_annotated_gr <- function(df) {
  
  # Check colnames -------------------------------------------------------------
  essential_col <- c("chr", "start", "end")
  for (i in 1:length(essential_col)) {
    if (!essential_col[i] %in% colnames(df)) {
      message("Please make sure you have the following column: ", essential_col[i])
      return (0)
    } 
  }
  remove(essential_col, i)
  
  ## Filter out non-standard chr
  wanted <- paste0("chr", seq(1:23))
  wanted <- c(wanted, "chrX", "chrY")
  df <- df |>
    dplyr::filter(chr %in% wanted) |>
    dplyr::mutate(start = as.numeric(start),
                  end = as.numeric(end)) |>
    dplyr::mutate(ix_id = paste0(chr, "_", start, "_", end))
  
  # Seperate the interaction counts into two data frame ------------------------
  ## As the interaction is built from i-j as well as j-i interaction
  ## So i-j interaction = j-i interaction
  ## Therefore we have to reverse the start ane end position for j-i interaction
  ## For creating GRange objects
  ## The ix_id column is used as the identity column
  
  df_reversed <- df |>
    dplyr::mutate(start_end_distance = end - start) |>
    dplyr::mutate(start_reversed = ifelse(start_end_distance >= 0, start, end),
                  end_reversed = ifelse(start_end_distance < 0, start, end)) |>
    dplyr::select(chr, start_reversed, end_reversed, ix_id)
  
  # Create GRange objects ------------------------------------------------------
  gr <- GRanges(
    seqnames = df_reversed$chr,
    ranges = IRanges(start = df_reversed$start_reversed, end = df_reversed$end_reversed),
    ix_id = df_reversed$ix_id
  )
  
  # Finding overlap ------------------------------------------------------------
  features <- transcripts(txdb)
  
  # Select the id of closet genes ----------------------------------------------
  ## nearest from peak start
  ps.idx <- follow(gr, features)
  
  ## nearest from peak end
  pe.idx <- precede(gr, features)
  
  ## check if any peak not matched to the nearest gene
  na.idx <- is.na(ps.idx) & is.na(pe.idx)
  
  ## Remove na 
  if (sum(na.idx) > 0) { ## suggested by Thomas Schwarzl
    ps.idx <- ps.idx[!na.idx]
    pe.idx <- pe.idx[!na.idx]
    gr <- gr[!na.idx]
  }
  
  # Generate the final data frame ----------------------------------------------
  ## Identify the closet gene information
  features_df <- data.frame(txStart = start(features[ps.idx]),
                            txEnd = end(features[pe.idx]),
                            txStrand = strand(features[ps.idx]),
                            tx_id = features[ps.idx]$tx_id,
                            tx_name = features[ps.idx]$tx_name)
  
  features_df <- features_df |> 
    dplyr::mutate(distanceToTSS = ifelse(txStrand == "+", txEnd - txStart, txStart - txEnd))
  
  gr_df <- as.data.frame(gr)
  annotated_df <- cbind(gr_df, features_df)
  annotated_df <- annotated_df[,6:ncol(annotated_df)]
  
  annotated_reversed_df <- df_reversed |>
    dplyr::select(ix_id) |>
    dplyr::left_join(annotated_df, by = "ix_id")
  
  final_df <- df |>
    dplyr::left_join(annotated_reversed_df, by = "ix_id") |>
    dplyr::select(-c(ix_id))
  
  ## map to the gene ids
  mapped_genes <- select(txdb, 
                         keys = final_df$tx_name, 
                         keytype = "TXNAME", 
                         columns = c("GENEID"))
  
  ## map to the gene names
  gene_symbols <- select(hgdb,
                         keys = mapped_genes$GENEID,
                         keytype = "ENTREZID",
                         columns = c("SYMBOL"))
  gene_symbols <- cbind(gene_symbols, mapped_genes)
  
  final_df <- cbind(final_df, gene_symbols)
  
  return(final_df)
}
